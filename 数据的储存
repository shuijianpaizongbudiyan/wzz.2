//                                   数据的储存                                    //
#include<stdio.h>
整形类型char int short long
浮点型类型 float double
构造类型  (数组类型 结构体类型struct 枚举类型enum 联合类型union)
数组类型  int arr[10];->数组名 int[10]是一个数组类型，int[5]又是一种数组类型 char[10]也是一种类型
指针类型 int* pi char* pc void* pv
空类型 void

整形类型的储存
 对于整形来说 数据内存存放的是补码
CPU只有加法
1-1 -> 1+(-1)
00000000000000000000000000000001
11111111111111111111111111111111
100000000000000000000000000000000去掉第一个
00000000000000000000000000000000 = 0
int main()
{
	int a = 20;
	//00000000000000000000000000000010100
	//0x 00 00 00 14
	//存在内存里是0x 14 00 00 00//小端储存模式
	//地址           低       高
}
大端储存模式，是指数据的低位保存在内存的高地址中，数据高位保存在内存的低位中
小端储存模式，是指数据的低位保存在内存的低地址中，数据高位保存在内存的高位中
低地址->高地址

判断机器用的是字节序是什么
int main()
{
	int a = 1;
	char* p = (char*)&a;
	if (*p == 1)
	{
		printf("小端\n");
	}
	else
	{
		printf("大端\n");
	}
	return 0;
}

int check_sys()
{
	int a = 1;
	char* p = (char*)&a;
	if (*p == 1)
		return 1;
	else
		return 0;
	//int a = 0;
	//return *(char*)&a;
}
int main()
{
	int ret = check_sys();
	if (ret == 1)
	{
		printf("小端\n");
	}
	else
	{
		printf("大端\n");
	}
}

int main()
{
	char a = -1;
	signed char b = -1;
	unsigned char c = -1;
	printf("a = %d b = %d c = %d", a, b, c);
	return 0;
	//a->11111111111111111111111111111111 - 补码
	//符号数整形提升在前面加符号,a的补码没变,a还是-1,b同理
	//c-无符号数-高位补0；00000000000000000000000011111111-255
}

int main()
{
	char a = -128;//128也是
	printf("%u\n", a);
	//a - 10000000000000000000000010000000原
	//    11111111111111111111111101111111番
	//    11111111111111111111111110000000补
	//但是%u打印的是十进制的无符号数字,补码就是原码2的32次方-2的7次方
}

有符号的char的范围-128-127
无符号的char的范围0-255

int main()
{
	int a = -20;
	unsigned int b = 10;
	printf("%d\n", a + b);
	return 0;
	//计算时用补码，最后格式化为有符号数
}

int main()
{
	//unsigned int i;
	for (i = 9;i >= 0;i--)
	{
		printf("%u\n", i);
		Sleep(100);
	}
	return 0;
	//9 8 7 6 5 4 3 2 1 死循环
}

int main()
{
	char a[1000];
	int i;
	for (i = 0;i < 1000;i++)
	{
		a[i] = -1 - i;
	}
	printf("%d", strlen(a));
	return 0;
	//char的范围-128-127
	//-1 -2 -3 ...-128 127 ...1...0  到0停止,0不算
}

                             浮点数在内存中的储存
int main()
{
    //9.0
    //1001.0
    //(-1)^0 * 1.001 * 2^3
    //(-1)^s *   M   * 2^E
    //s取决于正负，E是小数点前位数减一
    //实际M中只有小数点之后的数字
    //s->1bit  E->8bit  M->23bit  32bit 
    //s->1bit  E->11bit M->52bit  64bit
    //0.5
    //0.1 - 2的-1次方
    //1.0 * 2 ^ (-1)
    //E = -1
    //E + 127 = 126  //存在E的真实值   /32bit   8bit的中间数为127  范围0-255
    //E + 1023 = 1022//存在E的真实值   /64bit  11bit的中间数为1023 范围0-2047
    //正负都要加，126或者1022要转化为二进制
    int a = 9;
    float* pfloat = (float*)&a;
    printf("a = %d\n", a);
    printf("*float = %f\n", *pfloat);
    
    *pfloat = 9.0;
    printf("num = %d\n", a);
    printf("*pfloat = %f\n", *pfloat);
    return 0;
}

int main()
{
    float f = 5.5;
    //5.5
    //101.1
    //(-1)^0 * 1.011 * 2^2
    //s = 0
    //M = 1.011
    //E = 2 实际是129 100000001
    //0 100000001 0110000000000000000000
    //0100 0000 1011 0000 0000 0000 0000 0000
    //0x40b00000
    return 0;
}
回到上面那个题
9
00000000000000000000000000001001
0 00000000 00000000000000000001001
E全为0 特殊 0.00000000000000000001001 * 2^-126 = 0；-126规定值
9.0
1001.0
(-1)^0 * 1.001 * 2^3
0 10000010 00100000000000000000000 - 1091567616
